<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <title>Trabalho Final</title>
  <style>
    body {
      font-family: Arial, Helvetica, sans-serif;
      background: linear-gradient(to right, #f0f4f8, #d9e4ec);
      margin: 0;
      padding: 0;
      color: #333;
    }

    .menu-toggle {
      position: fixed;
      top: 20px;
      left: 20px;
      font-size: 28px;
      cursor: pointer;
      background-color: #ffffffcc;
      padding: 8px 12px;
      border-radius: 6px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      z-index: 1001;
    }

    .sidebar {
      width: 250px;
      background-color: #1e3a8a;
      color: white;
      height: 100vh;
      position: fixed;
      top: 0;
      left: -250px; 
      padding-top: 60px;
      box-shadow: 2px 0 5px rgba(0,0,0,0.1);
      transition: left 0.3s ease;
      z-index: 1000;
    }

    .sidebar.open {
      left: 0;
    }

    .sidebar h3 {
      padding: 10px 20px;
      margin: 0;
      cursor: pointer;
      background-color: #1e3a8a;
      border: none;
      text-align: left;
      font-size: 18px;
    }

    .sidebar h3:first-of-type {
      margin-top: 30px;
    }

    .sidebar h3:hover {
      background-color: #163273;
    }

    .dropdown-content {
      display: none;
      background-color: #2c4a9a;
      padding-left: 20px;
    }

    .dropdown-content a {
      display: block;
      color: white;
      padding: 10px 0;
      text-decoration: none;
      font-size: 16px;
    }

    .dropdown-content a:hover {
      background-color: #3a5cb4;
    }

    header {
      text-align: center;
      padding: 40px 20px;
      background-color: #1e3a8a;
      color: white;
      margin-left: 0;
    }

    header h1 {
      margin: 0;
      font-size: 2.5rem;
    }

    header p {
      margin: 10px 0 0;
      font-size: 1.2rem;
    }

    main {
      max-width: 900px;
      margin: 40px auto;
      padding: 20px;
      transition: margin-left 0.3s ease;
    }

    .sidebar.open ~ .content main {
      margin-left: 270px;
    }

    section {
      margin-bottom: 30px;
    }

    h2 {
      color: #1e3a8a;
      margin-bottom: 10px;
    }

    h3 {
      color: #2c4a9a;
      margin-top: 20px;
    }

    p {
      line-height: 1.6;
    }

    /* Estilo para os diagramas de bloco, fluxogramas e código */
    pre {
      background-color: #ecf0f1;
      padding: 15px;
      border-radius: 5px;
      border: 1px solid #bdc3c7;
      font-family: 'Courier New', Courier, monospace;
      line-height: 1.4;
      overflow-x: auto; /* Garante que o diagrama não quebre o layout */
      white-space: pre;
      font-size: 14px;
    }

    ul.membros {
      padding-left: 20px;
    }
  </style>
</head>
<body>

  <div class="menu-toggle" onclick="toggleSidebar()">☰</div>

  <div class="sidebar" id="sidebar">
    <h3 onclick="toggleDropdown('trabalhos')">Trabalhos</h3>
    <div id="trabalhos" class="dropdown-content">
      <a href="assistente_culinario/relatorio_final.html" target="_blank">Relatório final</a>
    </div>

    <h3 onclick="toggleDropdown('relatorios')">Relatórios</h3>
    <div id="relatorios" class="dropdown-content">
      <a href="relatorios/relatorio_1/relatorio1.html" target="_blank">Relatório 1</a>
      <a href="relatorios/relatorio_2/relatorio2.html" target="_blank">Relatório 2</a>
      <a href="relatorios/relatorio_3/relatorio3.html" target="_blank">Relatório 3</a>
      <a href="relatorios/relatorio_4/relatorio4.html" target="_blank">Relatório 4</a>
      <a href="relatorios/relatorio_5/relatorio5.html" target="_blank">Relatório 5</a>
      <a href="relatorios/relatorio_6/relatorio6.html" target="_blank">Relatório 6</a>
      <a href="relatorios/relatorio_7/relatorio7.html" target="_blank">Relatório 7</a>
    </div>
  </div>

  <div class="content">
    <header>
      <h1>Assistente de Culinária Interativo Integrado</h1>
      <p>UFABC</p>
    </header>

    <main>
      <section>
        <h2>Membros</h2>
        <ul class="membros">
          <li>Nayara Victoria Verísimo Matos | 11202111131</li>
          <li>George Salvino de Souza junior | 11201720464</li>
          <li>Thiago Tanios Devienne Pompeu | 11202321520</li>
          <li>Thiago de Souza Paschoim | 11202320430</li>
        </ul>
      </section>

      <section>
        <h1>Contexto e Cenário de Aplicação</h1>
        <h2>Tema: Assistente de Culinária Interativo por Gestos</h2>

        <div>
            <h2>O problema a ser abordado, seu contexto, e sua justificativa e motivação</h2>
            <p>
                Cozinhar seguindo uma receita digital em dispositivos como tablets, celulares ou notebooks tornou-se uma prática extremamente comum no dia a dia. No entanto, o cenário da cozinha apresenta um desafio prático significativo: as mãos do cozinheiro estão frequentemente sujas, molhadas, engorduradas ou cobertas com ingredientes como farinha. A necessidade de tocar na tela para pausar, retroceder ou avançar o vídeo da receita é inconveniente, anti-higiênica e interrompe o fluxo do preparo. Essa interação forçada pode danificar os aparelhos e causar contaminação cruzada.
            </p>
            <p>
                A <strong>motivação</strong> do projeto é eliminar completamente esse atrito, desenvolvendo uma solução que permita ao usuário interagir com o conteúdo da receita de forma totalmente "hands-free" (mãos livres), criando uma experiência de cozinha mais fluida, limpa, moderna e tecnológica.
            </p>
        </div>

        <div>
            <h2>O objetivo do sistema, o que será o resultado final para o usuário leigo</h2>
            <p>
                O objetivo é criar um reprodutor de vídeo inteligente, especializado para receitas, que seja controlado por gestos. O resultado final para o usuário será uma aplicação simples e intuitiva onde ele pode dar comandos de <strong>"play"</strong>, <strong>"pause"</strong>, <strong>avançar para o próximo passo</strong> ou <strong>voltar ao passo anterior</strong> apenas realizando gestos simples com a mão no ar. Estes gestos serão capturados e interpretados em tempo real pela câmera do seu próprio computador ou tablet, sem a necessidade de qualquer hardware adicional.
            </p>
        </div>

        <div>
            <h2>Como se usa o sistema (Qual o tipo de interatividade do usuário)</h2>
            <p>
                A interatividade do usuário com o sistema é puramente gestual e visual, projetada para ser simples e natural no ambiente da cozinha:
            </p>
            <ul>
                <li>O usuário inicia a aplicação e carrega o vídeo da receita que deseja seguir.</li>
                <li>Ele posiciona seu dispositivo (notebook ou tablet) em um local conveniente na cozinha, garantindo que a câmera frontal tenha uma visão clara de seus movimentos.</li>
                <li>Para <strong>pausar ou retomar</strong> o vídeo, ele simplesmente levanta a mão aberta em frente à câmera.</li>
                <li>Para <strong>avançar</strong> para a próxima etapa da receita, ele realiza um gesto de "arrastar" com a mão para a esquerda no ar.</li>
                <li>Para <strong>retroceder</strong> a um passo anterior, ele realiza o mesmo gesto de "arrastar", mas para a direita.</li>
            </ul>
        </div>

        <div>
            <h2>Qual o benefício do sistema ao usuário?</h2>
            <p>
                O principal benefício para o usuário é a combinação de <strong>conveniência e higiene</strong>. O sistema elimina a frustração de sujar a tela ou de ter que lavar as mãos repetidamente para controlar um vídeo. Isso permite que o usuário mantenha o foco total no cozimento, tornando o processo de seguir uma receita digital mais prático, agradável e, acima de tudo, mais limpo.
            </p>
        </div>

      </section>

      <section>
        <h1>Parte 2: Modelagem Funcional do Sistema (MF)</h1>
        <h2>Assistente de Culinária Interativo por Gestos</h2>

        <p>A concepção funcional do sistema é baseada em um ciclo de processamento em tempo real, conhecido como <em>loop principal</em>. A cada iteração deste ciclo, o sistema executa uma sequência de captura, processamento, análise e ação. O objetivo é criar um pipeline onde a informação visual (o vídeo do usuário) é transformada em comandos discretos que controlam uma aplicação (o player de vídeo da receita).</p>

        <h2>Diagrama de Blocos Funcional</h2>

        <p>Este diagrama representa os módulos de software e o fluxo de informação entre eles.</p>

        <pre>
      +------------------+     +------------------------+     +---------------------------+
      |      CÂMERA      | --> |  1. MÓDULO DE CAPTURA  | --> | 2. MÓDULO DE DETECÇÃO E   |
      |    (Hardware)    |     |      DE VÍDEO          |     |    RASTREAMENTO DE MÃO    |
      +------------------+     +------------------------+     +---------------------------+
                                          |                                |
                                          | Frame Bruto (Webcam)           | Coordenadas da Mão (Landmarks)
                                          V                                V
+-------------------------+     +-------------------------+     +---------------------------+
| 6. MÓDULO DE EXIBIÇÃO   | <-- | 5. CONTROLE DO PLAYER   | <-- | 3. MÓDULO DE RECONHECIMENTO|
|       (GUI)             |     |    DE VÍDEO             |     |       DE GESTOS           |
|                         |     +-------------------------+     +---------------------------+
| - Vídeo da Webcam       |                 | Comando (Ex: PAUSE)           | Comando (Ex: AVANÇAR)
| - Esqueleto da Mão      |                 |                               |
| - Feedback (Ex:"PAUSA") |                 V                               |
| - Vídeo da Receita      |     +-------------------------+                 |
+-------------------------+     | 4. PLAYER DA RECEITA    | <---------------+
                              |   (Estado e Vídeo)      |
                              +-------------------------+
        </pre>

        <h2>Descrição Detalhada dos Blocos Funcionais</h2>
        <p>Cada bloco do diagrama é descrito abaixo, detalhando suas responsabilidades, informações de entrada, processamento realizado e informações de saída.</p>

        <div>
            <h3>Bloco 1: Módulo de Captura de Vídeo</h3>
            <p><strong>Informação de Entrada:</strong> Sinal de vídeo contínuo proveniente do hardware da câmera (webcam).</p>
            <p><strong>Processamento Realizado:</strong></p>
            <ol>
                <li>Interface com o sistema operacional para acessar o dispositivo de câmera.</li>
                <li>Captura um quadro (frame) individual do fluxo de vídeo a uma taxa de quadros constante (ex: 30 FPS).</li>
                <li>Converte o quadro capturado em uma estrutura de dados manipulável, tipicamente uma matriz multidimensional de pixels (ex: um array NumPy no Python). O formato de cor padrão é geralmente BGR.</li>
            </ol>
            <p><strong>Informação de Saída:</strong> Um único frame de vídeo como uma matriz de pixels (ex: 640x480x3), que serve como a entrada principal para o resto do pipeline de processamento visual.</p>
        </div>

        <div>
            <h3>Bloco 2: Módulo de Detecção e Rastreamento de Mão</h3>
            <p><strong>Informação de Entrada:</strong> Frame de vídeo (matriz de pixels) vindo do <strong>Bloco 1</strong>.</p>
            <p><strong>Processamento Realizado:</strong></p>
            <ol>
                <li>Pré-processamento da imagem: O frame é convertido do espaço de cores BGR para RGB, que é o formato esperado por muitos modelos de machine learning, como o MediaPipe.</li>
                <li>Inferência do Modelo: O frame RGB é passado para um modelo de visão computacional pré-treinado (ex: MediaPipe Hands) que detecta a presença de mãos na imagem.</li>
                <li>Extração de Pontos-Chave: Se uma mão é detectada, o modelo calcula e retorna as coordenadas (x, y, z) de 21 pontos-chave, ou <em>landmarks</em>, que formam um "esqueleto" da mão.</li>
            </ol>
            <p><strong>Informação de Saída:</strong> Uma estrutura de dados contendo as coordenadas normalizadas (valores entre 0 e 1) de todos os 21 <em>landmarks</em> da mão detectada. Se nenhuma mão for encontrada, a saída é nula ou vazia.</p>
        </div>

        <div>
            <h3>Bloco 3: Módulo de Reconhecimento de Gestos</h3>
            <p><strong>Informação de Entrada:</strong> Coordenadas dos 21 <em>landmarks</em> da mão (vindo do <strong>Bloco 2</strong>). Também pode receber o estado do gesto do frame anterior para detectar movimentos.</p>
            <p><strong>Processamento Realizado:</strong> Este é o núcleo da lógica do sistema. Ele aplica um conjunto de regras heurísticas para traduzir a geometria e o movimento da mão em um comando.</p>
            <ol>
                <li><strong>Análise Estática (Pose):</strong> Verifica a posição relativa dos <em>landmarks</em> em um único frame. Exemplo: Para o gesto "Mão Aberta" (Pausar), o sistema verifica se as pontas dos cinco dedos estão verticalmente acima de suas respectivas juntas inferiores.</li>
                <li><strong>Análise Dinâmica (Movimento):</strong> Compara a posição da mão (ex: o <em>landmark</em> do pulso) entre o frame atual e os frames anteriores. Exemplo: Para o gesto "Arrastar para a Esquerda" (Avançar), o sistema detecta um deslocamento horizontal negativo rápido e significativo.</li>
                <li><strong>Gerenciamento de Estado:</strong> Inclui um temporizador de <em>cooldown</em> para evitar que um único gesto longo gere múltiplos comandos.</li>
            </ol>
            <p><strong>Informação de Saída:</strong> Um comando discreto e inequívoco, representado como uma string ou enum (ex: <code>COMANDO_PAUSAR</code>, <code>COMANDO_AVANCAR</code>, <code>COMANDO_NENHUM</code>).</p>
        </div>

        <div>
            <h3>Bloco 4: Player da Receita</h3>
            <p><strong>Informação de Entrada:</strong> Comandos discretos (<code>COMANDO_PAUSAR</code>, <code>COMANDO_AVANCAR</code>, <code>COMANDO_RETROCEDER</code>) vindos do <strong>Bloco 3</strong> e <strong>Bloco 5</strong>.</p>
            <p><strong>Processamento Realizado:</strong> Este bloco gerencia o estado do vídeo da receita.</p>
            <ol>
                <li>Mantém o estado atual (ex: <code>reproduzindo</code>, <code>pausado</code>).</li>
                <li>Mantém o ponteiro para o frame atual do vídeo.</li>
                <li>Ao receber um comando, altera seu estado. Ex: se recebe <code>COMANDO_PAUSAR</code>, alterna o estado entre <code>reproduzindo</code> e <code>pausado</code>. Se recebe <code>COMANDO_AVANCAR</code>, adianta o ponteiro do frame em um número pré-definido (ex: 150 frames para avançar 5 segundos).</li>
            </ol>
            <p><strong>Informação de Saída:</strong> O frame de vídeo atual da receita (se estiver em estado <code>reproduzindo</code>) e o estado atual (para o <strong>Bloco 5</strong>).</p>
        </div>

        <div>
            <h3>Bloco 5: Controle do Player de Vídeo</h3>
            <p><em>(Este bloco atua como o controlador que interpreta os comandos do módulo de gestos e os aplica ao player de vídeo.)</em></p>
            <p><strong>Informação de Entrada:</strong> Comando discreto vindo do <strong>Bloco 3</strong>.</p>
            <p><strong>Processamento Realizado:</strong></p>
            <ol>
                <li>Recebe o comando (ex: <code>COMANDO_PAUSAR</code>).</li>
                <li>Envia a instrução correspondente para o <strong>Bloco 4: Player da Receita</strong>.</li>
                <li>Gera uma mensagem de feedback visual para o usuário (ex: a string "PAUSADO").</li>
            </ol>
            <p><strong>Informação de Saída:</strong> Um sinal de feedback visual para o <strong>Bloco 6</strong> e o comando de ação para o <strong>Bloco 4</strong>.</p>
        </div>

        <div>
            <h3>Bloco 6: Módulo de Exibição (GUI)</h3>
            <p><strong>Informação de Entrada:</strong> O frame original da webcam, as coordenadas dos <em>landmarks</em> da mão, o feedback visual do <strong>Bloco 5</strong>, e o frame atual do vídeo da receita do <strong>Bloco 4</strong>.</p>
            <p><strong>Processamento Realizado:</strong></p>
            <ol>
                <li>Compõe a interface final que será mostrada ao usuário.</li>
                <li>Renderiza o vídeo da webcam em uma área da tela.</li>
                <li>Desenha o esqueleto da mão (os <em>landmarks</em> e as conexões) sobre a imagem da webcam para dar feedback de que o sistema está "vendo" o usuário.</li>
                <li>Renderiza o vídeo da receita em outra área da tela.</li>
                <li>Se houver feedback de um comando (ex: "PAUSADO"), exibe este texto temporariamente sobre a tela.</li>
            </ol>
            <p><strong>Informação de Saída:</strong> A imagem final renderizada na tela do computador do usuário.</p>
        </div>

        <h2>Fluxograma do Loop Principal do Sistema</h2>
        <p>O fluxograma abaixo detalha a sequência de operações dentro de uma única iteração do loop principal do programa.</p>

        <pre>
[ Início ]
    |
    V
[ Inicializar Câmera, Player e Modelo de Detecção ]
    |
    V
/-------------------------\
|      INÍCIO DO LOOP     |
\-------------------------/
    |
    V
[ 1. Capturar Frame da Webcam ]
    |
    V
[ 2. Detectar Landmarks da Mão no Frame ]
    |
    V
< Mão foi detectada? > --(Não)--> [ Pular para Etapa 5 ]
    |
    | (Sim)
    V
[ 3. Reconhecer Gesto (Estático ou Dinâmico) ]
    |
    V
< Gesto de Comando foi Reconhecido? > --(Não)--> [ Pular para Etapa 5 ]
    |
    | (Sim)
    V
[ 4. Traduzir Gesto em Comando e Atualizar Estado do Player ]
    |
    V
[ 5. Preparar Frame da Receita (Lê o próximo ou repete o atual se pausado) ]
    |
    V
[ 6. Renderizar a Saída Visual (Webcam + Esqueleto da Mão + Vídeo da Receita + Feedback) ]
    |
    V
[ 7. Exibir a Saída na Tela ]
    |
    V
< Usuário solicitou para sair (ex: apertou 'q')? > --(Sim)--> [ FIM ]
    |
    | (Não)
    V
/-------------------------\
|      FIM DO LOOP        | --> (Volta para o Início do Loop)
\-------------------------/
        </pre>
        
      </section>

      <section>
        <h1>Instruções de Instalação e Execução</h1>
        <p>Para utilizar o programa, siga os passos abaixo no terminal do Linux. Certifique-se de que a webcam esteja conectada.</p>

        <h3>1. Download do Código Fonte</h3>
        <p>Baixe o projeto do GitHub e extraia o arquivo ZIP.</p>
        <ul>
            <li>Link do Repositório: <a href="https://github.com/nayvvm/nayvvm.github.io" target="_blank">https://github.com/nayvvm/nayvvm.github.io</a></li>
        </ul>

        <h3>2. Instalação das Dependências</h3>
        <p>Abra o terminal e execute os seguintes comandos (um bloco por vez) para instalar as bibliotecas necessárias:</p>
        <pre>
sudo apt update
sudo apt install build-essential pkg-config libopencv-dev libsfml-dev libopenal-dev zenity ffmpeg curl

sudo apt install pipx
pipx ensurepath
pipx install yt-dlp
</pre>

        <h3>3. Compilação e Execução</h3>
        <p>Navegue até a pasta do projeto (ajuste o caminho se necessário), compile o código C++ e execute o programa:</p>
        <pre>
cd /home/ufabc/Downloads/nayvvm.github.io-main/assistente_culinario

g++ main.cpp -o assistente_culinario $(pkg-config --cflags --libs opencv4) -lsfml-audio -lsfml-system

./assistente_culinario
</pre>
      </section>

      <section>
        <h2>Informações</h2>
        <p>
          Disciplina: Processamento de Vídeo <br>
          Professor: Celso Setsuo Kurashima <br>
        </p>
      </section>
    </main>
  </div>

  <script>
    function toggleDropdown(id) {
      const el = document.getElementById(id);
      el.style.display = el.style.display === 'block' ? 'none' : 'block';
    }

    function toggleSidebar() {
      const sidebar = document.getElementById('sidebar');
      sidebar.classList.toggle('open');
    }
  </script>
</body>
</html>
