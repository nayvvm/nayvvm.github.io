<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <title>Relatório 2</title>
  <style>
    body {
      font-family: Arial, Helvetica, sans-serif;
      background: linear-gradient(to right, #f0f4f8, #d9e4ec);
      margin: 0;
      padding: 0;
      color: #333;
    }

    img {
      height: 80%;
      width: 80%;
    }

    .menu-toggle {
      position: fixed;
      top: 20px;
      left: 20px;
      font-size: 28px;
      cursor: pointer;
      background-color: #ffffffcc;
      padding: 8px 12px;
      border-radius: 6px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      z-index: 1001;
    }

    .sidebar {
      width: 250px;
      background-color: #1e3a8a;
      color: white;
      height: 100vh;
      position: fixed;
      top: 0;
      left: -250px; 
      padding-top: 60px;
      box-shadow: 2px 0 5px rgba(0,0,0,0.1);
      transition: left 0.3s ease;
      z-index: 1000;
    }

    .sidebar.open {
      left: 0;
    }

    .sidebar h3 {
      padding: 10px 20px;
      margin: 0;
      cursor: pointer;
      background-color: #1e3a8a;
      border: none;
      text-align: left;
      font-size: 18px;
    }

    .sidebar h3:first-of-type {
      margin-top: 30px;
    }

    .sidebar h3:hover {
      background-color: #163273;
    }

    .dropdown-content {
      display: none;
      background-color: #2c4a9a;
      padding-left: 20px;
    }

    .dropdown-content a {
      display: block;
      color: white;
      padding: 10px 0;
      text-decoration: none;
      font-size: 16px;
    }

    .dropdown-content a:hover {
      background-color: #3a5cb4;
    }

    header {
      text-align: center;
      padding: 40px 20px;
      background-color: #1e3a8a;
      color: white;
      margin-left: 0;
    }

    header h1 {
      margin: 0;
      font-size: 2.5rem;
    }

    header p {
      margin: 10px 0 0;
      font-size: 1.2rem;
    }

    main {
      max-width: 900px;
      margin: 40px auto;
      padding: 20px;
      transition: margin-left 0.3s ease;
    }

    .sidebar.open ~ .content main {
      margin-left: 270px;
    }

    section {
      margin-bottom: 30px;
    }

    h2 {
      color: #1e3a8a;
      margin-bottom: 10px;
    }

    p {
      line-height: 1.6;
    }

    ul.membros {
      padding-left: 20px;
    }
    
    code, pre {
      font-family: "Fira Code", "Consolas", monospace;
      background-color: #f5f5f5;
      color: #333;
      padding: 4px 8px;
      border-radius: 4px;
    }
    
    pre {
      display: block;
      padding: 12px;
      overflow-x: auto;
      white-space: pre;
    }
  </style>
</head>
<body>

  <header>
    <h1>Relatório 2 - Filtragem de Imagens</h1>
  </header>

  <main>
    <section>
      <h2>Introdução</h2>
      <p>
        Este relatório tem como objetivo conhecer os comandos para filtragem de imagens.
      </p>
    </section>

    <section>
      <h2>Materiais e Métodos</h2>
      <p>
        Foi utilizado o seguinte código para aplicar filtros na mesma imagem tirada através de uma webcam no laboratório. Os filtros aplicados foram Kernel 3x3, 5x5, 7x7, 11x11 para a imagem sem ruído e com ruído pimenta. 
      </p>
      <pre><code>
      #include &lt;iostream&gt;
      #include "opencv2/imgproc.hpp"
      #include "opencv2/imgcodecs.hpp"
      #include "opencv2/highgui.hpp"

      using namespace std;
      using namespace cv;

      int DELAY_CAPTION = 1500;
      int DELAY_BLUR = 100;
      int MAX_KERNEL_LENGTH = 31;

      Mat src; Mat dst;
      char window_name[] = "Smoothing Demo";

      int display_caption( const char* caption );
      int display_dst( int delay );

      int main( int argc, char ** argv )
      {
          namedWindow( window_name, WINDOW_AUTOSIZE );

          const char* filename = argc &gt;=2 ? argv[1] : "lena.jpg";

          src = imread( samples::findFile( filename ), IMREAD_COLOR );
          if (src.empty())
          {
              printf(" Error opening image\n");
              printf(" Usage:\n %s [image_name-- default lena.jpg] \n", argv[0]);
              return EXIT_FAILURE;
          }

          if( display_caption( "Original Image" ) != 0 )
          {
              return 0;
          }

          dst = src.clone();
          if( display_dst( DELAY_CAPTION ) != 0 )
          {
              return 0;
          }

          if( display_caption( "Homogeneous Blur" ) != 0 )
          {
              return 0;
          }

          for ( int i = 1; i &lt; MAX_KERNEL_LENGTH; i = i + 2 )
          {
              blur( src, dst, Size( i, i ), Point(-1,-1) );
              if( display_dst( DELAY_BLUR ) != 0 )
              {
                  return 0;
              }
          }

          if( display_caption( "Gaussian Blur" ) != 0 )
          {
              return 0;
          }

          for ( int i = 1; i &lt; MAX_KERNEL_LENGTH; i = i + 2 )
          {
              GaussianBlur( src, dst, Size( i, i ), 0, 0 );
              if( display_dst( DELAY_BLUR ) != 0 )
              {
                  return 0;
              }
          }

          if( display_caption( "Median Blur" ) != 0 )
          {
              return 0;
          }

          for ( int i = 1; i &lt; MAX_KERNEL_LENGTH; i = i + 2 )
          {
              medianBlur ( src, dst, i );
              if( display_dst( DELAY_BLUR ) != 0 )
              {
                  return 0;
              }
          }

          if( display_caption( "Bilateral Blur" ) != 0 )
          {
              return 0;
          }

          for ( int i = 1; i &lt; MAX_KERNEL_LENGTH; i = i + 2 )
          {
              bilateralFilter ( src, dst, i, i*2, i/2 );
              if( display_dst( DELAY_BLUR ) != 0 )
              {
                  return 0;
              }
          }

          display_caption( "Done!" );

          return 0;
      }

      int display_caption( const char* caption )
      {
          dst = Mat::zeros( src.size(), src.type() );
          putText( dst, caption,
                   Point( src.cols/4, src.rows/2),
                   FONT_HERSHEY_COMPLEX, 1, Scalar(255, 255, 255) );

          return display_dst(DELAY_CAPTION);
      }

      int display_dst( int delay )
      {
          imshow( window_name, dst );
          int c = waitKey ( delay );
          if( c &gt;= 0 ) { return -1; }
          return 0;
      }
      </code></pre>
    </section>

    <section>
      <h2>Resultados e Análises</h2>
      <img src="kernel_3x3.png" width="1000">
      <img src="kernel_5x5.png" width="1000">
      <img src="kernel_7x7.png" width="1000">
      <img src="kernel_11x11.png" width="1000">
      <img src="sal_pimenta_3x3.png" width="1000">
      <img src="sal_pimenta_5x5.png" width="1000">
      <img src="sal_pimenta_7x7.png" width="1000">
      <img src="sal_pimenta_11x11.png" width="1000">

      <p>
        Pelos resultados obtidos, percebemos que:
        1. Filtro da Média<br>
        Variação com o tamanho do Kernel: Kernel pequeno (3×3) tem a suavização leve, mantém alguns detalhes.
        Kernel grande (11×11) tem a suavização forte, mas a imagem perde nitidez e definição.<br>
        Com ruído sal e pimenta: o ruído contém pixels pretos e brancos e a média não consegue eliminá-los totalmente.<br>
        2. Filtro Gaussiano<br>
        Variação com o tamanho do kernel: Quanto maior o kernel maior a suavização, mas a suavização é menor que o filtro da média.<br>
        Com ruído sal e pimenta: O Gaussiano melhora um pouco, os pontos brancos e pretos aparecem mais que o filtro anterior.<br>
        3. Filtro da Mediana<br>
        Variação com o tamanho do kernel: O Kernel pequeno (3×3) remove ruído leve. O Kernel grande (7×7 ou 11×11): remove mais ruído, mas começa a borrar algumas regiões.<br>
        Com ruído sal e pimenta: É o melhor filtro para esse tipo de ruído, remove quase todos os pontos de ruído, mantendo contornos nítidos.<br>
        4. Filtro Bilateral<br>
        Variação com o tamanho do kernel: Kernels maiores tornam o efeito de suavização mais evidente, mas mantêm bordas mais definidas que os outros filtros.<br>
        Com ruído sal e pimenta: Funciona razoavelmente bem, mas não tanto quanto o filtro da mediana.<br>
      </p>
    </section>
    
    <section>
      <h2>Conclusões e Comentários Finais</h2>
      <p>
        A partir da aplicação dos diferentes filtros de suavização — média, gaussiano, mediana e bilateral — com variados tamanhos de kernel (3×3, 5×5, 7×7 e 11×11), foi possível observar de forma clara como cada técnica atua na redução de ruídos e na preservação dos detalhes da imagem.<br>
        De maneira geral, verificou-se que o aumento do tamanho do kernel provoca uma suavização mais intensa, reduzindo significativamente o ruído, porém com o custo de perda de nitidez e definição dos contornos. Kernels menores (como 3×3) mantêm mais detalhes, enquanto kernels maiores (como 11×11) deixam a imagem mais borrada.<br>
        Em imagens com ruído sal e pimenta, o filtro da mediana é claramente o mais eficaz.<br>
        O estudo evidencia que a escolha do filtro e do tamanho do kernel deve considerar o tipo de ruído e o objetivo da filtragem, buscando sempre o equilíbrio entre a suavização desejada e a preservação das características visuais originais da imagem.<br>
      </p>
    </section>

  </main>

</body>
</html>
